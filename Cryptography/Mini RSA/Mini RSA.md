# [Mini RSA](https://play.picoctf.org/practice/challenge/188)

## Overview

**Points**: 70

**Category**: [Cryptography](../)

## Description

What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M \*\* e) is just barely larger than N. Let's decrypt this: [ciphertext](./ciphertext)

## Hints

1. RSA [tutorial](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
2. How could having too small of an `e` affect the security of this key?
3. Make sure you don't lose precision, the numbers are pretty big (besides the `e` value)
4. You shouldn't have to make *too* many guesses
5. `pico` is in the flag, but not at the beginning

## Solution

Normally for a small exponent `e`, its easy to crack if $c = m^e < n$. Because $m^e < n$, then taking the modulus with a larger `n` would not affect the value of `m^e`.

$$c = m^e \bmod n = m^e$$

Then, the ciphertext can be decrypted by taking the `e`-th root of `c`:

$$m = c^{1/e}$$

However, in our problem, $m^e \geq n$, so the above formula doesn't work.

To solve, we first need to understand that the `mod` operator returns the remainder of the division. \
For example, `16 mod 15 = 1`. This means that `16` divided by `15` has a remainder of `1`. \
We can rewrite this as `16 = 15 * i + 1`, which means multiplying `15` by some "integer" and adding `1` would result in `16` (in this case, the integer `i = 1`). \
We can break it down further by saying `4^2 = 15 * i + 1`, where `i = 1`. \
So in order to find the value of `4`, we can take the square root as follows, `(15 * 1 + 1)^(1/2)`.

$$
\begin{align*}
& 16 \bmod 15 = 1 \\
\implies & 16 = 15 \times i  + 1 \\
\implies & 16 = 15 \times 1 + 1 \\
\implies & 4^2 = 15 \times 1 + 1 \\
\implies & 4 = (15 \times 1 + 1)^{(1/2)} \\
\end{align*}
$$

So, `m^e mod n = c` means `m^e` divided by `n` has a remainder of `c`. \
This means that `m^e` is a multiple of `n` plus `c`, which can be written as `m^e = n * i + c`. \
To find `m`, we can take the `e`-th root of `n * i + c` to get `m = (n * i + c)^(1/e)`.

$$
\begin{align*}
& m^e \bmod n = c \\
\implies & m^e = n \times i + c \\
\implies & m = (n \times i + c)^{1/e} \\
\end{align*}
$$

Source: https://crypto.stackexchange.com/a/6771

Script is in [mini_rsa.py](./mini_rsa.py).

```python
from Crypto.Util.number import *
from sage.all import *

n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730

for i in range(10000):
    m = int(real_nth_root(n * i + c, e))
    flag = long_to_bytes(m)
    if b"pico" in flag:
        print(flag.decode().strip())
        break
```

## Flag

`picoCTF{e_sh0u1d_b3_lArg3r_85d643d5}`
